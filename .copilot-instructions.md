# XNOM (X Notification Manager) - AI Copilot Instructions

## Project Overview

XNOM is a TypeScript/Node.js application that manages X (Twitter) notifications, analyzes post ideas with AI, and automates engagement on high-performing posts. It features a web interface for monitoring and controlling all functionality.

## Architecture

- **Backend**: Node.js with Express, TypeScript, SQLite database
- **Frontend**: HTML/CSS/JavaScript with WebSocket real-time updates
- **AI Integration**: OpenAI API for content analysis and generation
- **X API**: Twitter API v2 for social media interactions

## Key Components

### Services

- `DatabaseService`: SQLite operations for notifications, engagements, post ideas, settings
- `XService`: Twitter API integration with rate limiting and retry logic
- `AIService`: OpenAI integration for post analysis and content generation
- `NotificationService`: Real-time notification monitoring with WebSocket broadcasting
- `EngagementService`: Auto-engagement with high-performing tweets, robust like handling

### API Routes

- `/api/notifications`: Notification management and monitoring control
- `/api/engagement`: Auto-engagement control and manual actions
- `/api/post-ideas`: AI-powered post analysis and generation
- `/api/settings`: User settings and configuration

### Frontend

- Dashboard with real-time stats and system status
- Notification monitoring and management interface
- Engagement tracking and manual controls
- Post idea analysis and generation tools
- Settings configuration panel

## Development Guidelines

### Code Style

- Use TypeScript with strict type checking
- Follow async/await patterns for asynchronous operations
- Implement comprehensive error handling with try/catch blocks
- Use meaningful variable and function names
- Add JSDoc comments for complex functions

### Database Operations

- Use parameterized queries to prevent SQL injection
- Implement proper transaction handling for multi-step operations
- Add database indexes for frequently queried columns
- Handle database connection errors gracefully

### API Development

- Return consistent JSON response format: `{ success: boolean, data?: any, error?: string }`
- Implement proper HTTP status codes
- Add request validation and sanitization
- Use middleware for common functionality (logging, auth, etc.)

### Error Handling

- Log errors with appropriate context and stack traces
- Return user-friendly error messages
- Implement fallback mechanisms for external API failures
- Add retry logic for transient failures (especially X API)

### Security Considerations

- Store API keys and secrets in environment variables
- Implement rate limiting to prevent abuse
- Validate and sanitize all user inputs
- Use HTTPS in production
- Add CORS configuration for frontend access

## X API Integration

### Rate Limiting

- Like endpoint: 300 requests per 15-minute window
- Tweet lookup: 300 requests per 15-minute window
- Implement exponential backoff for rate limit errors
- Track usage per endpoint and respect limits

### Retry Logic

- Use robust retry mechanism for failed likes (common issue)
- Implement exponential backoff: 1s, 2s, 4s delays
- Maximum 3 retry attempts per action
- Log all retry attempts for debugging

### Best Practices

- Cache tweet data to reduce API calls
- Use appropriate expansions to get complete data
- Handle pagination for large result sets
- Respect Twitter's automation rules and guidelines

## AI Integration

### OpenAI Usage

- Use GPT-3.5-turbo for cost-effective analysis
- Implement proper prompt engineering for consistent results
- Add fallback logic when AI service is unavailable
- Cache AI responses to reduce API costs

### Analysis Types

- **Post Ideas**: Score 1-10 with detailed reasoning
- **Engagement Potential**: Binary decision with confidence score
- **Content Generation**: Topic-based post idea generation
- **Reply Generation**: Context-aware automated responses

## Database Schema

### Core Tables

- `notifications`: Real-time notification storage
- `engagement_actions`: Track all engagement attempts and results
- `post_ideas`: Store analyzed and generated post ideas
- `settings`: User configuration and preferences

### Indexing Strategy

- Index `timestamp` columns for time-based queries
- Index `tweet_id` for engagement deduplication
- Index `success` column for stats queries

## Frontend Development

### Real-time Updates

- WebSocket connection for live data streaming
- Automatic reconnection on connection loss
- Handle connection state in UI (connected/disconnected indicator)

### User Experience

- Responsive design for mobile and desktop
- Dark theme with professional appearance
- Loading states and progress indicators
- Error notifications and success feedback

### Performance

- Lazy load data for large lists
- Implement virtual scrolling for large datasets
- Cache frequently accessed data
- Optimize WebSocket message handling

## Environment Configuration

### Required Variables

```env
# X API Credentials
X_BEARER_TOKEN=your_bearer_token
X_API_KEY=your_api_key
X_API_SECRET=your_api_secret
X_ACCESS_TOKEN=your_access_token
X_ACCESS_TOKEN_SECRET=your_access_token_secret

# OpenAI Configuration
OPENAI_API_KEY=your_openai_api_key

# Application Settings
NODE_ENV=development
PORT=3000
LOG_LEVEL=info

# Feature Flags
AUTO_ENGAGEMENT_ENABLED=true
AI_ANALYSIS_ENABLED=true

# Rate Limiting
MAX_LIKES_PER_HOUR=50
HIGH_ENGAGEMENT_THRESHOLD=100
ENGAGEMENT_DELAY_MS=2000
```

## Testing Strategy

### Unit Tests

- Test database operations with in-memory SQLite
- Mock external API calls (X API, OpenAI)
- Test error handling and edge cases
- Validate data transformation logic

### Integration Tests

- Test API endpoints with test database
- Verify WebSocket communication
- Test service integration points
- Validate end-to-end workflows

### Manual Testing

- Test with real X API (limited scope)
- Verify UI responsiveness and functionality
- Test error scenarios and recovery
- Validate auto-engagement behavior

## Deployment Considerations

### Production Setup

- Use environment-specific configuration
- Implement proper logging and monitoring
- Set up database backups and migration scripts
- Configure reverse proxy (nginx) if needed

### Monitoring

- Log application metrics and errors
- Monitor API rate limit usage
- Track engagement success rates
- Set up alerts for critical failures

## Common Issues & Solutions

### X API Like Failures

- Problem: Likes often fail silently or with unclear errors
- Solution: Implemented robust retry logic with exponential backoff
- Monitoring: Track retry attempts and success rates

### Rate Limiting

- Problem: Hitting X API rate limits during high activity
- Solution: Implement intelligent rate limiting with usage tracking
- Monitoring: Log rate limit headers and adjust delays accordingly

### Database Performance

- Problem: Slow queries on large datasets
- Solution: Add appropriate indexes and implement pagination
- Monitoring: Log slow queries and optimize as needed

## Future Enhancements

### Features

- Advanced AI-powered content scheduling
- Multi-account support
- Enhanced analytics and reporting
- Integration with other social platforms
- Mobile app development

### Technical Improvements

- Implement proper user authentication
- Add comprehensive test suite
- Set up CI/CD pipeline
- Implement caching layer (Redis)
- Add API documentation (Swagger)

## Troubleshooting

### Common Commands

```bash
# Start development server
npm run dev

# Build for production
npm run build

# Run tests
npm test

# Database operations
npm run db:migrate
npm run db:seed

# Check logs
tail -f logs/app.log
```

### Debug Mode

Set `LOG_LEVEL=debug` to enable verbose logging for troubleshooting issues with API calls and data processing.
